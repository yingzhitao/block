### synchronized的实现原理

Synchronized的作用：

1、确保线程互斥的访问同步代码

2、保证共享变量的修改能够及时可见

3、有效解决重排序问题

同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。

方法级的同步是隐式，即无需通过字节码指令来控制的。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。



### 数据库锁与隔离级别的关系

未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据；

提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)；

可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 串行读(Serializable)；

完全串行化的读：每次读都需要获得表级共享锁，读写相互都会阻塞



### 数据库锁与索引的关系

索引分为主键索引和非主键索引两种

如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；

主键索引的节点存的是整行数据

如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引

非主键索引的节点的内容是主键的值



### 聚簇索引与非聚簇索引

聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据

非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因



### B+树索引

B+ Tree是B Tree的升级版，其最大的特点便是中间节点只有链指针和key，而不存储数据，所有的value都会存储在B+Tree的叶子节点中，所以基于树的深度，B+Tree的查询时间复杂度很稳定，每次都要搜索到叶子节点

由此，因为中间文档小，B+Tree作为索引可以提升查找效率，同时在MySQL的索引中，叶子结点各有指针指向相邻的数据，便于范围查找

索引B+ Tree的叶子节点存储了整行数据的是主键索引



### 什么是回表

简单来说就是数据库根据索引找到了指定的记录所在行后,还需要根据rowid再次到数据块里取数据的操作



### 分布式锁

为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个分布式锁

