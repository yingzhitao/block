### synchronized的实现原理

Synchronized的作用：

1、确保线程互斥的访问同步代码

2、保证共享变量的修改能够及时可见

3、有效解决重排序问题

同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。

方法级的同步是隐式，即无需通过字节码指令来控制的。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。



### 数据库锁与隔离级别的关系

未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据；

提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)；

可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 串行读(Serializable)；

完全串行化的读：每次读都需要获得表级共享锁，读写相互都会阻塞



### 数据库锁与索引的关系

索引分为主键索引和非主键索引两种

如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；

主键索引的节点存的是整行数据

如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引

非主键索引的节点的内容是主键的值



### 聚簇索引与非聚簇索引

聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据

非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因



### B+树索引

B+ Tree是B Tree的升级版，其最大的特点便是中间节点只有链指针和key，而不存储数据，所有的value都会存储在B+Tree的叶子节点中，所以基于树的深度，B+Tree的查询时间复杂度很稳定，每次都要搜索到叶子节点

由此，因为中间文档小，B+Tree作为索引可以提升查找效率，同时在MySQL的索引中，叶子结点各有指针指向相邻的数据，便于范围查找

索引B+ Tree的叶子节点存储了整行数据的是主键索引



### 什么是回表

简单来说就是数据库根据索引找到了指定的记录所在行后,还需要根据rowid再次到数据块里取数据的操作



### 分布式锁

为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个分布式锁

分布式锁实现方式：

1、数据库

2、redis等缓存

3、zookeeper



redis实现分布式锁

setnx命令，存储数据时，如果当前key已经存在，则返回0，表示没有设置成功，否则返回1，表示设置成功。分布式锁的实现就可以通过是否设置成功某个key来判断是否获取到锁，为了防止死锁问题，还应该为该key设置超时时间，为了防止误删别人的锁，需要返回value,在释放锁时判断当前想要删除的锁是否是自己的锁

为什么选择使用redis实现分布式锁

Redis内存操作，速度快
Redis数据会同步保存到硬盘，数据有持久性(存在一定丢失可能)
支持分布式
用的人多，社区支持好，有问题能及时得到解决



### Redis和Memcache区别

数据类型：redis支持的数据类型更多
缓存值大小：redis支持的缓存值更大
数据持久性：redis支持数据持久，memcache数据只保存在内存中，容易丢失



### Zookeeper怎么实现分布式锁

使用临时节点：这里需要使用当zk的监听zk节点的变化，在请求进来时，尝试去创建一个约定名称的零时节点，如果创建成功，则表示能获取锁，可以进行操作，操作完成之后关闭连接，zk会自动删除该临时节点。如果创建临时节点失败，则等待，监听该节点名称，当该节点发生变化时，会通知到所有监听带节点的客户端，所以当服务器监听到该节点的删除事件时，可以尝试再次创建节点，重复之前的操作，知道获取锁成功，断开连接。使用有序节点时需要手动删除自己创建的节点，是否获取到锁就判断当前客户端节点在zk中是否排在第一位

什么是Zookeepr

ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件

分布式协调工具，可以作为注册中心，分布式锁，分布式配置中心等



### 什么是CAP，什么是BASE

CAP: C: 一致性 A:可用性 P:分区容错性

对于分布式系统而言，三者不能同时满足，分区容错性是必须的，需要把精力花在如何根据业务特点在C和A之间寻求平衡。

网络发生故障宁可停止服务也不能发生服务泄露

BASE: BA:基本可用 S:软状态，允许系统在不同节点的数据副本之间进行数据同步过程存在延时 E:最终一致性



分布式事务保证分布式系统的数据的一致性

分布式事务的核心是解决多机系统中的原子性和一致性(AC)问题



Paxos算法是基于消息传递且具有高度容错特性的一致性算法



ArrayList和Vector底层是数据结构实现，LinkedList是双向链表，ArrayList和Vector查询快，删除慢，LinkedList与之相反，ArrayList是线程不安全的，性能优于Vector，Vector是线程安全的，能解决线程安全问题

SynchronizedList采用的同步代码块方式，vector采用的同步方法实现。所以主要区别： 

1.SynchronizedList有很好的扩展和兼容功能。可以将所有的List的子类转成线程安全的类 

2.使用SynchronizedList的时候，进行遍历时要手动进行同步处理。

3.SynchronizedList可以指定锁定的对象。

asList 得到的只是一个 Arrays 的内部类，一个原来数组的视图 List，因此如果对它进行增删操作会报错，用 ArrayList 的构造器可以将其转变成真正的 ArrayList



### List和原始类型List之间的区别

在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查

### List<?>和List之间的区别

一个是已知的，一个是未知的



synchronized的三种应用方式：

　　synchronized有三种方式来加锁，分别是：方法锁，对象锁synchronized(this)，类锁synchronized(Demo.Class)。其中在方法锁层面可以有如下3种方式：

1. 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁
2. 静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁
3. 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁

为什么每个对象都可以成为锁呢？ 因为每个 Java Object 在 JVM 内部都有一个 native 的 C++ 对象 oop/oopDesc 与之对应，而对应的 oop/oopDesc 都会存在一个markOop 对象头，而这个对象头是存储锁的位置，里面还有对象监视器，即ObjectMonitor，所以这也是为什么每个对象都能成为锁的原因之一。



自旋锁（CAS）：

　　自旋锁就是让不满足条件的线程等待一段时间，而不是立即挂起。看持有锁的线程是否能够很快释放锁。怎么自旋呢？其实就是一段没有任何意义的循环。虽然它通过占用处理器的时间来避免线程切换带来的开销，但是如果持有锁的线程不能在很快释放锁，那么自旋的线程就会浪费处理器的资源，因为它不会做任何有意义的工作。所以，自旋等待的时间或者次数是有一个限度的，如果自旋超过了定义的时间仍然没有获取到锁，则该线程应该被挂起。JDK1.6中-XX:+UseSpinning开启； -XX:PreBlockSpin=10 为自旋次数； JDK1.7后，去掉此参数，由jvm控制；

偏向锁：

　　大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。

当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成01（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。执行同步块。这个时候线程2也来访问同步块，也是会检查对象头的Mark Word里是否存储着当前线程2的偏向锁，发现不是，那么他会进入 CAS 替换，但是此时会替换失败，因为此时线程1已经替换了。替换失败则会进入撤销偏向锁，首先会去暂停拥有了偏向锁的线程1，进入无锁状态(01).偏向锁存在竞争的情况下就回去升级成轻量级锁。

开启：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 -client -Xmx1024m -Xms1024m

关闭：-XX:+UseBiasedLocking -client -Xmx512m -Xms512m

轻量级锁：

　　引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁

在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。这个时候 JVM会尝试使用 CAS 将 mark Word 更新为指向栈帧中的锁记录（Lock Record）的空间指针。并且把锁标志位设置为 00(轻量级锁标志)，与此同时如果有另外一个线程2也来进行 CAS 修改 Mark Word，那么将会失败，因为线程1已经获取到该锁，然后线程2将会进行 CAS操作不断的去尝试获取锁，这个时候将会引起锁膨胀，就会升级为重量级锁，设置标志位为 10.

　　由轻量锁切换到重量锁，是发生在轻量锁释放锁的期间，之前在获取锁的时候它拷贝了锁对象头的markword，在释放锁的时候如果它发现在它持有锁的期间有其他线程来尝试获取锁了，并且该线程对markword做了修改，两者比对发现不一致，则切换到重量锁。轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示同步过程已完成。如果失败，表示有其他线程尝试过获取该锁，则要在释放锁的同时唤醒被挂起的线程进入等待。 

重量级锁：

　　重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。主要是，当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。这就是说为什么重量级线程开销很大的。

　　monitor这个对象，在hotspot虚拟机中，通过ObjectMonitor类来实现 monitor。他的锁的获取过程的体现会简单很多。每个object的对象里 markOop->monitor() 里可以保存ObjectMonitor的对象。

wait和notify的原理：

　　调用wait方法，首先会获取监视器锁，获得成功以后，会让当前线程进入等待状态进入等待队列并且释放锁；然后当其他线程调用notify或者notifyall以后，会通知等待线程可以醒了，而执行完notify方法以后，并不会立马唤醒线程，原因是当前的线程仍然持有这把锁，处于等待状态的线程无法获得锁。必须要等到当前的线程执行完按monitorexit指令以后，也就是锁被释放以后，处于等待队列中的线程就可以开始竞争锁了。

wait和notify为什么需要在synchronized里面:

　　wait方法的语义有两个，一个是释放当前的对象锁、另一个是使得当前线程进入阻塞队列， 而这些操作都和监视器是相关的，所以wait必须要获得一个监视器锁。

　　而对于notify来说也是一样，它是唤醒一个线程，既然要去唤醒，首先得知道它在哪里？所以就必须要找到这个对象获取到这个对象的锁，然后到这个对象的等待队列中去唤醒一个线程。



### ConcurrentSkipListMap

一个内部使用跳表，支持排序和并发的一个Map



String.valueOf 当值为null 返回字符null 否则调起tostring

nteger会有个常量数组，缓存 -128 到 127的值。 与此类似的还有Long

Set如何保证元素不重复

HashSet底层使用的是hashMap的key来保证元素不重复的，hashMap中的key通过equals方法比较key是否相等

Java中可以使用synchronized关键保证线程安全，也可以使用jdk提供的Lock锁，或者使用cas乐观锁来实现线程安全



微服务的数据一致性问题，目前的解决方案是
1、使用TCC方式，或者Saga方式，达到最终一致性
2、阿里巴巴开源的Fescar框架可以考虑一下。
微服务如果使用http协议的REST API 由于其协议的根本特性，所以没有办法，为了性能，放弃了强一致性。



### 异常处理机制

1、处理或者继续抛出catch块中的异常
2、使用明确具体的异常类型
3、不要捕获Exception类而是捕获特定的子类
4、始终正确地将异常包装在自定义异常中，以便不会丢失堆栈跟踪
5、永远不要在finally块中抛出任何异常
6、不要使用printStackTrace（）语句或类似方法
7、始终在单个日志消息中包含有关异常的所有信息
8、在javadoc中描述程序中的所有异常



### 使用Docker的目的

docker 本身解决的问题是一个单点部署的问题。但是只有docker和调度器结合之后才真正展示出效率。单点故障的自动恢复，从此不再依赖外围的脚本



### Spring和Spring Boot的区别

Spring框架为开发Java应用程序提供了全面的基础架构支持。它包含一些很好的功能，如依赖注入和开箱即用的模块，如：        Spring JDBC 、Spring MVC 、Spring Security、 Spring AOP 、Spring ORM 、Spring Test 

Spring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。以下是Spring Boot中的一些特点：  

1：创建独立的spring应用。  

2：嵌入Tomcat, Jetty Undertow 而且不需要部署他们。  

3：提供的“starters” poms来简化Maven配置  

4：尽可能自动配置spring应用。  

5：提供生产指标,健壮检查和外部化配置  

6：绝对没有代码生成和XML配置要求